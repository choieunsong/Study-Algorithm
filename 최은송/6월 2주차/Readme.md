# 6월 2주차 풀이
## 1. BOJ G5 14520 연구소🧪
### 문제 정의

1. N*M 직사각형 모양의 연구소에 빈 칸(0), 벽(1), 바이러스(2)가 있다.
2. 바이러스는 상하좌우로 퍼진다.
3. 연구소에 딱 3개의 벽을 설치해서 빈칸(0)의 수를 최대가 되게 했을 때, 안전영역의 최댓값을 구하시오
4. 3 ≤ N, M ≤ 8, 2 ≤ 2의개수 ≤ 10

### 문제 풀이

1. 칸의 개수가 최대 64이고 선택할 벽의 수가 3개이므로 완전탐색 64C3으로 풀 수 있다.
2. 0인 칸 중에서 3개를 고른다
3. 바이러스를 상하좌우로 퍼트린다.
4. 남은 빈칸의 개수를 세고 최대값과 비교 갱신한다.

### 정리

간단한 bfs 문제였다.

----
## BOJ G4 1963 소수경로🧭
### 문제 정의

1. 네자리  소수 A, B가 주어진다. 
2. A에서 B로 바꾸는데 한번에 한자리씩밖에 못바꾼다 
3. A에서 B로 바꾸는 과정에서도 항상 네자리 소수를 유지해야 하고,  1000 이상의 수여야 한다.
4. A에서 B로 바꾸는데 필요한 최소회수를 출력하시오. 불가능한 경우 Impossible을 출력한다.

### 문제 풀이

1. 에라토스테네스의 체 + bfs
2. 에라토스테네스의 체로 1000 ~ 10000  사이의 모든  소수를 구한다.
3. bfs로 start부터 큐에 넣어서 각 자리씩 숫자를 바꾼다. 바꾼 값이 수가 소수이고 아직 사용하지 않은 수면 큐에 값을 offer해준다.
4. 큐에서 poll한 수가 end와 같으면 cnt를 리턴하고 종료
5. 만약 bfs가 끝나면 -1 리턴

### 정리

아이디어는 쉽게 떠올랐는데 각 자리를 하나씩 바꾸는게 까다로웠다. int로 바꾸려니까 너무 까다로울 것 같아서 찾아보니 StringBuilder로 쉽게 인덱스의 문자를 바꿀 수 있어서 금방 해결했다!

---
## 3. BOJ G2 1561 놀이공원🎡
### 문제 정의

1. N명의 아이들이 줄을 서서 M개의 놀이기구 중 하나를 타려고 한다.
2. 모든 놀이기구를 운행 시간이 정해져 있고, 놀이 기구가 비어 있으면 현재 줄에서 가장 앞에 서 있는 아이가 빈 놀이기구에 탑승한다. 만일 여러 개의 놀이기구가 동시에 비어 있으면 더 작은 번호의 놀이기구를 탄다.
3. 마지막 아이가 타는 놀이기구의 번호를 구하시오
4. 1 ≤ N ≤ 2,000,000,000, 1 ≤ M ≤ 10,000, 1 ≤ 운행시간 ≤ 30

### 문제 풀이

#### 아이디어 1

```java
0분: 1, 2, 3, 4, 5 -> 5개 : 0 ~ 5   5
1분: 1             -> 1개 : 5 ~ 6   6
2분: 1, 2          -> 2개 : 6 ~ 8   8
3분: 1, 3          -> 2개 : 8 ~ 10  10
4분: 1, 2, 4       -> 3개 : 10 ~ 13 13
5분: 1, 5          -> 2개 : 13 ~ 15 15
6분: 1, 2, 3       -> 3개 : 15 ~ 18 18
7분: 1             -> 1개 : 18 ~ 19 19
8분: 1, 2, 4       -> 3개 : 19 ~ 22 22
```

1. 놀이기구 시간의 배수마다 놀이기구가 빈다.  이를 이용해 각 놀이기구 시간의 배수일 때  arr[운행시간]의 cnt를 1 올려준다.
2. arr[운행시간]의 누적합을 구해서 마지막 아이 번호로 이분탐색을 진행한다.
- 최대 운행 시간이 600억일 수 있으므로 배열을 이용한 전략은 불가능

#### 아이디어 2

1. left = 0, right = 600억으로 해서 이분탐색 진행
    1. mid  시간일 때 탑승객 ≥ N: right = mid- 1, time = mid(시간기록)
    2. mid 시간일 때 탑승객 < N: left= mid + 1
2. 이분탐색이 끝나면 mid시간일 때 N번째 탑승객이 탄다. 예를 들어 22번째 탑승객이면 (7분: 19) < 22  (8분: 22) 이므로 8분에 놀이기구를 타게 된다.
3. (mid-1) 시간일 때 빈 놀이기구를 찾아서 N이 되 때의 놀이기구를 찾는다

### 정리

로직은 맞는 것 같은데 이분탐색에서 자꾸 범위를 벗어나서 3%에서 에러가 뜬다. ⇒ 애초에 N이 사이값으로 껴있기 때문에 탑승객수가 N보다 크거나 같을때의 시간을 기록해야 한다. 탑승객 수가 누적합으로 쌓이므로 N보다 크거나 같게 되는 최소 시간을 구해야 하므로 right = mid-1, left= mid+1이 되어야 한다. 이분탐색은 정말 어렵다ㅠㅠ
